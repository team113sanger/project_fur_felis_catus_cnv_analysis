import logging
from pathlib import Path
import shlex
import subprocess
import typing as t

from fur_cnvkit.utils.file_format_checker import is_bam, is_bed, is_fasta

logger = logging.getLogger(__name__)


# Helper functions
def run_command(command: str) -> None:
    """Run a given command using subprocess, including logging statements and exception handling.

    Args:
        command (str): Command to be executed.
    """
    logger.debug(f"Executing command: {command}")
    try:
        result = execute_command(command)
        log_success(command, result)
    except subprocess.CalledProcessError as e:
        log_error(command, e)


def execute_command(command: str) -> subprocess.CompletedProcess:
    """Execute a command using subprocess and return the result.

    Args:
        command (str): Command to execute.

    Returns:
        subprocess.CompletedProcess: The result of the executed command.

    Raises:
        subprocess.CalledProcessError: If the command fails.
    """
    command_list = shlex.split(command)
    return subprocess.run(
        command_list,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )


def log_success(command: str, result: subprocess.CompletedProcess) -> None:
    """Log the success of a command execution.

    Args:
        command (str): The executed command.
        result (subprocess.CompletedProcess): The result of the command execution.
    """
    logger.info(f"Successfully completed command: {command}")
    if result.stdout:
        logger.debug(f"Command Standard Output: {result.stdout.strip()}")
    if result.stderr:
        logger.debug(f"Command Standard Error: {result.stderr.strip()}")


def log_error(command: str, error: subprocess.CalledProcessError) -> None:
    """Log details of a failed command execution.

    Args:
        command (str): The command that failed.
        error (subprocess.CalledProcessError): The exception raised.
    """
    logger.error(f"Command '{command}' failed with exit code {error.returncode}")
    if error.stdout:
        logger.error(f"Error Output: {error.stdout.strip()}")
    if error.stderr:
        logger.error(f"Error Details: {error.stderr.strip()}")


def convert_file_list_to_string(files: t.List[Path]) -> str:
    if len(files) == 0:
        logger.warning("No files detected. Please check input data.")
        return ""
    elif len(files) == 1:
        file_path_string = str(
            files[0].absolute()
        )  # Only one file, just use its' string
    else:
        file_path_string = " ".join([str(file.absolute()) for file in files])

    return file_path_string


# CNVKit command wrappers
def run_cnvkit_access(reference_fasta: Path, outdir: Path) -> Path:
    """Run cnvkit.py acess on a given reference FASTA file

    Args:
        reference_fasta (Path): Path to the reference FASTA file
        outdir (Path): Path to directory where output file will be stored

    Returns:
        Path: Path to the output BED file containing sequence-accessible coordinates
    """
    logger.info("Preparing to run cnvkit.py access...")
    if is_fasta(reference_fasta):
        fasta_stem = reference_fasta.stem
        output_bed_name = f"access-{fasta_stem}.bed"
        output_bed_path = outdir / output_bed_name
        cmd = f"cnvkit.py access {str(reference_fasta)} -o {str(output_bed_path)}"

        run_command(cmd)
    else:
        raise ValueError(
            f"{str(reference_fasta)} is not a valid FASTA file. Check input data."
        )

    return Path(output_bed_path)


def run_cnvkit_autobin(
    bam_files: t.List[Path],
    baitset_bed: Path,
    access_bed: Path,
    refflat_file: Path,
    outdir: Path,
) -> dict[Path]:
    """Run cnvkit.py autobin to produce target and antitarget BED files

    Args:
        bam_files (list[Path]): Paths to BAM files
        baitset (Path): Path to the baitset BED file
        access_bed (Path): Path to the BED file generated by cnvkit.py access
        refflat (Path): Path to the refFlat gene annotation file
        outdir (Path): Path to directory where output files will be stored

    Returns:
        dict[Path]: A dictionary containing the target and antitarget BED files. Respective keys are 'target' and 'antitarget'
    """
    logger.info("Preparing to run cnvkit.py autobin...")
    # Validate input baitset BED and construct output BED paths
    if is_bed(baitset_bed):
        output_target_bed_name = baitset_bed.name.replace(".bed", ".target.bed")
        output_antitarget_bed_name = baitset_bed.name.replace(".bed", ".antitarget.bed")
        output_target_bed_path = outdir / output_target_bed_name
        output_antitarget_bed_path = outdir / output_antitarget_bed_name
    else:
        raise ValueError(
            f"{str(baitset_bed)} is not a valid BED file. Check input data"
        )

    # Validate input BAMs and construct BAM file string for cnvkit.py autobin command
    if all(is_bam(file) for file in bam_files):
        bam_files_as_string = map(str, bam_files)

    # Construct cnvkit.py autobin command
    cmd = (
        f'cnvkit.py autobin {" ".join(bam_files_as_string)} -t {str(baitset_bed)} '
        f"-g {str(access_bed)} --annotate {str(refflat_file)} "
        f"--target-output-bed {str(output_target_bed_path)} "
        f"--antitarget-output-bed {str(output_antitarget_bed_path)}"
    )

    # Run cnvkit.py autobin command
    run_command(cmd)

    # Create a dictionary containing cnvkit.py autobin output files
    target_bed_dict = dict()
    target_bed_dict["target"] = Path(output_target_bed_path)
    target_bed_dict["antitarget"] = Path(output_antitarget_bed_path)

    return target_bed_dict


def run_cnvkit_coverage(bam_file: Path, interval_bed: Path, outdir: Path) -> None:
    is_valid = True

    # Check if BAM file is valid
    if is_bam(bam_file):
        logger.info(f"BAM file {str(bam_file)} is valid")
    else:
        logger.error(f"BAM file {str(bam_file)} is not valid. Please check input data.")
        is_valid = False

    # Check if BED file is valid
    if is_bed(interval_bed):
        logger.info(f"BED file {str(interval_bed)} is valid")
    else:
        logger.error(
            f"BED file {str(interval_bed)} is not valid. Please check input data."
        )
        is_valid = False

    # If any file checks failed, raise an error
    if not is_valid:
        raise ValueError(
            f"{str(bam_file)} is not a valid BAM file and/or {str(interval_bed)} is not a valid BED file. Please check input data."
        )

    # If all file checks passed, run cnvkit.py coverage
    target_type = interval_bed.stem.split(".")[-1]
    output_file_name = bam_file.name.replace(".bam", f".{target_type}coverage.cnn")
    output_file_path = outdir / output_file_name

    # Construct cnvkit.py coverage command
    cmd = f"cnvkit.py coverage {str(bam_file)} {str(interval_bed)} -o {str(output_file_path)}"

    # Run cnvkit.py coverage command
    run_command(cmd)

    return output_file_path


def run_cnvkit_reference(
    coverage_files: t.List[Path],
    reference_fasta: Path,
    output_prefix: str,
    outdir: Path,
    sex: t.Literal["male", "female"],
) -> Path:
    # Construct a string containing the coverage file paths to pass to cvkit.py reference
    coverage_files_as_string = convert_file_list_to_string(coverage_files)

    # Construct output file path
    output_file_name = f"{output_prefix}.reference.cnn"
    output_file_path = outdir / output_file_name

    # Construct cnvkit.py reference command
    cnvkit_reference_command = f"cnvkit.py reference {coverage_files_as_string} -f {str(reference_fasta)} -o {str(output_file_path)}"

    # If dealing with male samples, create a male reference with -y
    if sex == "male":
        cnvkit_reference_command += " -y"

    # Run cnvkit.py reference command
    run_command(cnvkit_reference_command)

    return output_file_path


def run_cnvkit_fix(
    target_coverage_file: Path,
    antitarget_coverage_file: Path,
    copy_number_reference_file: Path,
    output_prefix: str,
    outdir: Path,
) -> Path:
    # Construct output file path
    output_file_name = f"{output_prefix}.cnr"
    output_file_path = outdir / output_file_name

    # Construct cnvkit.py fix command
    cnvkit_fix_command = f"cnvkit.py fix {str(target_coverage_file)} {str(antitarget_coverage_file)} {str(copy_number_reference_file)} -o {str(output_file_path)}"

    # Run cnvkit.py fix command
    run_command(cnvkit_fix_command)

    return output_file_path


def run_cnvkit_genemetrics(
    ratio_file: Path,
    threshold: float,
    min_probes: int,
    output_prefix: str,
    outdir: Path,
    sex: t.Literal["male", "female"],
    segment_file: Path = None,
) -> Path:
    """
    Run cnvkit.py genemetrics on a given bin-level log2 ratio file (Sample.cnr).
    Optionally include a segmentation file (Sample.cns). Returns the path to the output genemetrics file.

    Parameters:
        ratio_file (Path): Path to the ratio file (Sample.cnr).
        threshold (float): Threshold value for calling copy number variations.
        min_probes (int): Minimum number of probes required for a call.
        output_prefix (str): Prefix for the output file.
        outdir (Path): Directory to save the output file.
        sex (str): Sample sex, "male" or "female".
        segment_file (Path, optional): Path to the segmentation file (Sample.cns). Defaults to None.

    Returns:
        Path: Path to the generated genemetrics output file.
    """
    # Determine the output file name based on whether a segmentation file is provided
    suffix = "segments" if segment_file else "ratios"
    output_file_name = f"{output_prefix}.{suffix}.genemetrics.out"
    output_file_path = outdir / output_file_name

    # Construct the base cnvkit.py genemetrics command
    cnvkit_genemetrics_command = (
        f"cnvkit.py genemetrics {ratio_file} -t {threshold} -m {min_probes} "
        f"-o {output_file_path}"
    )

    # Add the segmentation file option if provided
    if segment_file:
        cnvkit_genemetrics_command += f" -s {segment_file}"

    # Add the male reference option if the sample is male
    if sex == "male":
        cnvkit_genemetrics_command += " -y"

    # Run the command
    run_command(cnvkit_genemetrics_command)

    return output_file_path


def run_cnvkit_batch(
    tumour_bams: t.List[Path],
    copy_number_reference_file: Path,
    outdir: Path,
    sex: t.Literal["male", "female"],
) -> Path:
    """
    Run the CNVkit batch command on a list of tumour BAM files.

    Args:
        tumour_bams (List[Path]): List of tumour BAM files.
        copy_number_reference_file (Path): Path to the copy number reference

    Returns:
    cnvkit_batch_outdir (Path): Path to the output directory containing the CNVKit batch results
    """
    # Construct a string containing the tumour BAM file paths to pass to cnvkit.py batch
    tumour_bams_as_string = convert_file_list_to_string(tumour_bams)
    cnvkit_batch_cmd = f"cnvkit.py batch {tumour_bams_as_string} -m hybrid --drop-low-coverage --reference {str(copy_number_reference_file)} --output-dir {str(outdir)}"

    # If dealing with male samples, specify that we are using a male reference
    if sex == "male":
        cnvkit_batch_cmd += " --male-reference"

    cmd = """Rscript -e 'if (!require("DNAcopy", quietly = TRUE)) stop("DNAcopy package is not installed.")'"""

    run_command(cmd)

    # Run cnvkit.py batch command
    print(f"{cnvkit_batch_cmd=}")
    run_command(cnvkit_batch_cmd)

    return outdir


# CNVKit file validation
def file_exists(file: Path) -> bool:
    """
    Check if the file exists.

    Args:
        file (Path): The file to check.

    Returns:
        bool: True if the file exists, False otherwise.
    """
    if not file.exists():
        logger.warning(
            f"The file '{file}' does not exist. Please check the input path."
        )
        return False
    return True


def is_regular_file(file: Path) -> bool:
    """
    Check if the path is a regular file.

    Args:
        file (Path): The file to check.

    Returns:
        bool: True if it's a regular file, False otherwise.
    """
    if not file.is_file():
        logger.warning(
            f"The path '{file}' is not a valid file. Please check the input."
        )
        return False
    return True


def has_correct_suffix(file: Path, expected_suffix: str) -> bool:
    """
    Check if the file has the expected suffix.

    Args:
        file (Path): The file to check.
        expected_suffix (str): The expected file suffix.

    Returns:
        bool: True if the file has the expected suffix, False otherwise.
    """
    if not file.name.endswith(expected_suffix):
        logger.warning(
            f"The file '{file}' has an unexpected suffix. Expected a '{expected_suffix}' file."
        )
        return False
    return True


def has_expected_header(file: Path, expected_header: str) -> bool:
    """
    Check if the file has the expected header.

    Args:
        file (Path): The file to check.
        expected_header (str): The expected header line in the file.

    Returns:
        bool: True if the file has the expected header, False otherwise.
    """
    try:
        with file.open() as f:
            actual_header = f.readline().strip()
        if actual_header == expected_header:
            logger.info(f"Successfully validated the structure of '{file}'.")
            return True
        else:
            logger.warning(
                f"The file '{file}' has unexpected columns. Expected: '{expected_header}'"
            )
            return False
    except Exception as e:
        logger.error(f"An error occurred while reading the file '{file}': {e}")
        return False


def is_valid_coverage_file(
    file: Path,
    expected_suffix: str = ".coverage.cnn",
    expected_header: str = "chromosome\tstart\tend\tgene\tdepth\tlog2",
) -> bool:
    """
    Check if an input coverage file has the expected structure.

    Args:
        file (Path): The file to validate.
        expected_suffix (str): The expected file suffix.
        expected_header (str): The expected header line in the file.

    Returns:
        bool: True if the file has the expected structure, False otherwise.
    """
    return (
        file_exists(file)
        and is_regular_file(file)
        and has_correct_suffix(file, expected_suffix)
        and has_expected_header(file, expected_header)
    )


def validate_sample_coverage_files(
    sample_id: str, sample_coverage_files: t.List[Path]
) -> t.Tuple[Path, Path]:
    """
    Validates that a sample has exactly one target coverage file and one antitarget coverage file.

    Args:
        sample_id (str): The unique identifier of the sample.
        sample_coverage_files (List[Path]): A list of file paths to check.

    Returns:
        Tuple[Path, Path]: A tuple containing the target coverage file and the antitarget coverage file.

    Raises:
        ValueError: If the expected files are missing or their counts are incorrect.

    Logs:
        Logs warnings for unexpected counts and information about successfully identified files.
    """

    def filter_files(file_list: t.List[Path], keyword: str) -> t.List[Path]:
        """Filter files containing the specified keyword in their names."""
        return [file for file in file_list if keyword in file.name]

    target_files = filter_files(sample_coverage_files, ".targetcoverage.cnn")
    antitarget_files = filter_files(sample_coverage_files, ".antitargetcoverage")

    if not target_files or not antitarget_files:
        raise ValueError(
            f"Insufficient coverage files for sample '{sample_id}'. "
            f"Expected one target and one antitarget file, but found: "
            f"Target files: {len(target_files)}, Antitarget files: {len(antitarget_files)}."
        )

    if len(target_files) > 1 or len(antitarget_files) > 1:
        logger.warning(
            f"Unexpected number of coverage files for sample '{sample_id}'. "
            f"Target files: {target_files}, Antitarget files: {antitarget_files}."
        )

    logger.info(
        f"Successfully identified coverage files for sample '{sample_id}'. "
        f"Target file: {target_files[0]}, Antitarget file: {antitarget_files[0]}."
    )

    return target_files[0], antitarget_files[0]


# CNVKit file parsing
def parse_genemetrics_file(file_path: Path):
    """Parse the genemetrics output file and return a list of log2(FC) values"""
    logging.info(f"Parsing genemetrics file {str(file_path)}")
    log2_values = []
    with file_path.open() as f:
        next(f)  # Skip the header line
        for line in f:
            parts = line.strip().split("\t")
            log2_value = float(parts[4])
            log2_values.append(log2_value)

    logging.debug(f"Log2(FC) values from {str(file_path)}: {log2_values}")
    return log2_values


# CNVKit file filtering
def filter_unplaced_contigs_from_cnvkit_output_file(
    cnvkit_output_file: Path, unplaced_contigs: t.List[str]
):
    logger.info(f"Removing unplaced contigs from {str(cnvkit_output_file)}...")

    # Read the CNVKit output file
    with cnvkit_output_file.open() as f:
        lines = f.readlines()

    # Filter out lines with unplaced contigs
    filtered_lines = [
        line
        for line in lines
        if not any(line.startswith(contig) for contig in unplaced_contigs)
    ]

    # Write the filtered lines back to the CNVKit output file
    with cnvkit_output_file.open("w") as f:
        f.writelines(filtered_lines)

    logger.info(
        f"Unplaced contigs removed from {str(cnvkit_output_file)}. Filtered {len(lines) - len(filtered_lines)} lines. Output saved to {str(cnvkit_output_file)}"
    )
