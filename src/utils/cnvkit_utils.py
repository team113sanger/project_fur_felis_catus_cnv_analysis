import logging
from pathlib import Path
import subprocess
import typing as t

from utils.file_format_checker import is_bam, is_bed, is_fasta

logger = logging.getLogger(__name__)


# Helper functions
def run_command(command: str) -> None:
    """Run a given command using subprocess, including logging statements and exception handling.

    Args:
        command (str): Command to be executed.
    """
    logger.debug(f"Executing command: {command}")
    try:
        result = execute_command(command)
        log_success(command, result)
    except subprocess.CalledProcessError as e:
        log_error(command, e)


def execute_command(command: str) -> subprocess.CompletedProcess:
    """Execute a command using subprocess and return the result.

    Args:
        command (str): Command to execute.

    Returns:
        subprocess.CompletedProcess: The result of the executed command.

    Raises:
        subprocess.CalledProcessError: If the command fails.
    """
    command_list = command.split()
    return subprocess.run(
        command_list,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )


def log_success(command: str, result: subprocess.CompletedProcess) -> None:
    """Log the success of a command execution.

    Args:
        command (str): The executed command.
        result (subprocess.CompletedProcess): The result of the command execution.
    """
    logging.info(f"Successfully completed command: {command}")
    if result.stdout:
        logger.debug(f"Command Standard Output: {result.stdout.strip()}")
    if result.stderr:
        logger.debug(f"Command Standard Error: {result.stderr.strip()}")


def log_error(command: str, error: subprocess.CalledProcessError) -> None:
    """Log details of a failed command execution.

    Args:
        command (str): The command that failed.
        error (subprocess.CalledProcessError): The exception raised.
    """
    logger.error(f"Command '{command}' failed with exit code {error.returncode}")
    if error.stdout:
        logger.error(f"Error Output: {error.stdout.strip()}")
    if error.stderr:
        logger.error(f"Error Details: {error.stderr.strip()}")


# CNVKit command wrappers
def run_cnvkit_access(reference_fasta: Path, outdir: Path) -> Path:
    """Run cnvkit.py acess on a given reference FASTA file

    Args:
        reference_fasta (Path): Path to the reference FASTA file
        outdir (Path): Path to directory where output file will be stored

    Returns:
        Path: Path to the output BED file containing sequence-accessible coordinates
    """
    logging.info("Preparing to run cnvkit.py access...")
    if is_fasta(reference_fasta):
        fasta_stem = reference_fasta.stem
        output_bed_name = f"access-{fasta_stem}.bed"
        output_bed_path = outdir / output_bed_name
        cmd = f"cnvkit.py access {str(reference_fasta)} -o {str(output_bed_path)}"

        run_command(cmd)
    else:
        raise ValueError(
            f"{str(reference_fasta)} is not a valid FASTA file. Check input data."
        )

    return Path(output_bed_path)


def run_cnvkit_autobin(
    bam_files: t.List[Path],
    baitset_bed: Path,
    access_bed: Path,
    refflat_file: Path,
    outdir: Path,
) -> dict[Path]:
    """Run cnvkit.py autobin to produce target and antitarget BED files

    Args:
        bam_files (list[Path]): Paths to BAM files
        baitset (Path): Path to the baitset BED file
        access_bed (Path): Path to the BED file generated by cnvkit.py access
        refflat (Path): Path to the refFlat gene annotation file
        outdir (Path): Path to directory where output files will be stored

    Returns:
        dict[Path]: A dictionary containing the target and antitarget BED files. Respective keys are 'target' and 'antitarget'
    """
    logging.info("Preparing to run cnvkit.py autobin...")
    # Validate input baitset BED and construct output BED paths
    if is_bed(baitset_bed):
        output_target_bed_name = baitset_bed.name.replace(".bed", ".target.bed")
        output_antitarget_bed_name = baitset_bed.name.replace(".bed", ".antitarget.bed")
        output_target_bed_path = outdir / output_target_bed_name
        output_antitarget_bed_path = outdir / output_antitarget_bed_name
    else:
        raise ValueError(
            f"{str(baitset_bed)} is not a valid BED file. Check input data"
        )

    # Validate input BAMs and construct BAM file string for cnvkit.py autobin command
    if all(is_bam(file) for file in bam_files):
        bam_files_as_string = map(str, bam_files)

    # Construct cnvkit.py autobin command
    cmd = (
        f'cnvkit.py autobin {" ".join(bam_files_as_string)} -t {str(baitset_bed)} '
        f"-g {str(access_bed)} --annotate {str(refflat_file)} "
        f"--target-output-bed {str(output_target_bed_path)} "
        f"--antitarget-output-bed {str(output_antitarget_bed_path)}"
    )

    # Run cnvkit.py autobin command
    run_command(cmd)

    # Create a dictionary containing cnvkit.py autobin output files
    target_bed_dict = dict()
    target_bed_dict["target"] = Path(output_target_bed_path)
    target_bed_dict["antitarget"] = Path(output_antitarget_bed_path)

    return target_bed_dict


def run_cnvkit_coverage(bam_file: Path, interval_bed: Path, outdir: Path) -> None:
    is_valid = True

    # Check if BAM file is valid
    if is_bam(bam_file):
        logging.info(f"BAM file {str(bam_file)} is valid")
    else:
        logging.error(
            f"BAM file {str(bam_file)} is not valid. Please check input data."
        )
        is_valid = False

    # Check if BED file is valid
    if is_bed(interval_bed):
        logging.info(f"BED file {str(interval_bed)} is valid")
    else:
        logging.error(
            f"BED file {str(interval_bed)} is not valid. Please check input data."
        )
        is_valid = False

    # If any file checks failed, raise an error
    if not is_valid:
        raise ValueError(
            f"{str(bam_file)} is not a valid BAM file and/or {str(interval_bed)} is not a valid BED file. Please check input data."
        )

    # If all file checks passed, run cnvkit.py coverage
    target_type = interval_bed.stem.split(".")[-1]
    output_file_name = bam_file.name.replace(".bam", f".{target_type}coverage.cnn")
    output_file_path = outdir / output_file_name

    # Construct cnvkit.py coverage command
    cmd = f"cnvkit.py coverage {str(bam_file)} {str(interval_bed)} -o {str(output_file_path)}"

    # Run cnvkit.py coverage command
    run_command(cmd)

    return output_file_path
